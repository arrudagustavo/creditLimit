document.addEventListener('DOMContentLoaded', () => {

    // --- CONFIGURAÇÕES E VARIÁVEIS GLOBAIS ---
    const API_BASE_URL = 'https://ws.sandbox.autorei.net'; 
    let BEARER_TOKEN = localStorage.getItem('bearerToken') || ''; // Carrega do localStorage
    let LOGGED_IN_USER_EMAIL = localStorage.getItem('userEmail') || ''; // Carrega do localStorage
    const USE_MOCK_API = false; 
    let currentLimits = [];
    let deletePayload = null;

    // --- ELEMENTOS DO DOM (TELA PRINCIPAL) ---
    const appScreen = document.getElementById('app');
    const searchInput = document.getElementById('searchInput');
    const searchButton = document.getElementById('searchButton');
    const tableBody = document.getElementById('creditLimitTableBody');
    const addLimitButton = document.getElementById('addLimitButton');
    const addTypeButton = document.getElementById('addTypeButton');
    const userEmailDisplay = document.getElementById('userEmailDisplay');
    const logoutButton = document.getElementById('logoutButton');
    const extractReportButton = document.getElementById('extractReportButton');
    
    // --- ELEMENTOS DO DOM (LOGIN) ---
    const loginScreen = document.getElementById('loginScreen');
    const loginForm = document.getElementById('loginForm');
    const emailInput = document.getElementById('email');
    const passwordInput = document.getElementById('password');
    const loginButton = document.getElementById('loginButton');
    const loginButtonText = document.getElementById('loginButtonText');
    const loginSpinner = document.getElementById('loginSpinner');
    
    // --- ELEMENTOS DO DOM (MODAIS) ---
    const formModal = document.getElementById('formModal');
    const modalTitle = document.getElementById('modalTitle');
    const closeModalButton = document.getElementById('closeModalButton');
    const cancelButton = document.getElementById('cancelButton');
    const creditLimitForm = document.getElementById('creditLimitForm');
    const saveLimitButton = document.getElementById('saveLimitButton');
    const isEditingInput = document.getElementById('isEditing');
    const documentoInput = document.getElementById('documento');
    const tipoSelect = document.getElementById('tipo');
    const valorInput = document.getElementById('valor');
    const saldoInput = document.getElementById('saldo');

    const typeFormModal = document.getElementById('typeFormModal');
    const closeTypeModalButton = document.getElementById('closeTypeModalButton');
    const cancelTypeButton = document.getElementById('cancelTypeButton');
    const creditTypeForm = document.getElementById('creditTypeForm');
    const typeNameInput = document.getElementById('typeName');
    const typeCodeInput = document.getElementById('typeCode');
    const saveTypeButton = document.getElementById('saveTypeButton');

    const deleteConfirmationModal = document.getElementById('deleteConfirmationModal');
    const documentToDeleteSpan = document.getElementById('documentToDelete');
    const typeToDeleteSpan = document.getElementById('typeToDelete');
    const cancelDeleteButton = document.getElementById('cancelDeleteButton');
    const confirmDeleteButton = document.getElementById('confirmDeleteButton');

    const reportModal = document.getElementById('reportModal');
    const closeReportModalButton = document.getElementById('closeReportModalButton');
    const cancelReportButton = document.getElementById('cancelReportButton');
    const reportForm = document.getElementById('reportForm');
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');
    const reportResultDiv = document.getElementById('reportResult');
    
    const notification = document.getElementById('notification');
    const notificationMessage = document.getElementById('notificationMessage');
    
    const warningModal = document.getElementById('warningModal');
    const warningMessage = document.getElementById('warningMessage');
    const closeWarningModalButton = document.getElementById('closeWarningModalButton');

    // --- FUNÇÕES DE LOGIN/LOGOUT ---
    
    function showLoginSpinner(show) {
        if (show) {
            loginButtonText.classList.add('hidden');
            loginSpinner.classList.remove('hidden');
            loginButton.disabled = true;
        } else {
            loginButtonText.classList.remove('hidden');
            loginSpinner.classList.add('hidden');
            loginButton.disabled = false;
        }
    }

    async function handleLogin(e) {
        e.preventDefault();
        showLoginSpinner(true);
        const email = emailInput.value;
        const password = passwordInput.value;

        // Simulação de login para desenvolvimento sem API
        if (USE_MOCK_API) {
            console.log("[MOCK] Tentativa de login para:", email);
            setTimeout(() => {
                BEARER_TOKEN = 'mock-token-para-desenvolvimento';
                LOGGED_IN_USER_EMAIL = email;
                localStorage.setItem('bearerToken', BEARER_TOKEN); // Armazena o token
                localStorage.setItem('userEmail', LOGGED_IN_USER_EMAIL); // Armazena o email
                userEmailDisplay.textContent = email;
                loginScreen.classList.add('hidden');
                appScreen.classList.remove('hidden');
                loadAndRenderLimits();
                showLoginSpinner(false);
            }, 1000);
            return;
        }

        const loginApiUrl = `${API_BASE_URL}/oauth/token`;
        const params = new URLSearchParams();
        params.append('scope', 'trust');
        params.append('grant_type', 'password');
        params.append('username', email);
        params.append('password', password);

        try {
            const response = await fetch(loginApiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Authorization': 'Basic YXBpLXdzOnBhc3N3b3JkLW1hc3Rlcg=='
                },
                body: params
            });

            if (!response.ok) {
                throw new Error('Email ou senha inválidos.');
            }

            const data = await response.json();
            BEARER_TOKEN = data.access_token;
            LOGGED_IN_USER_EMAIL = email;
            
            localStorage.setItem('bearerToken', BEARER_TOKEN); // Armazena o token
            localStorage.setItem('userEmail', LOGGED_IN_USER_EMAIL); // Armazena o email
            
            userEmailDisplay.textContent = email;
            loginScreen.classList.add('hidden');
            appScreen.classList.remove('hidden');
            loadAndRenderLimits();

        } catch (error) {
            console.error('Falha no login:', error);
            showNotification(error.message, 'error');
        } finally {
            showLoginSpinner(false);
        }
    }

    function handleLogout() {
        BEARER_TOKEN = '';
        LOGGED_IN_USER_EMAIL = '';
        localStorage.removeItem('bearerToken'); // Remove o token
        localStorage.removeItem('userEmail'); // Remove o email
        emailInput.value = '';
        passwordInput.value = '';
        
        appScreen.classList.add('hidden');
        loginScreen.classList.remove('hidden');
    }

    // Função para verificar se o token é válido
    async function checkTokenValidity() {
        if (!BEARER_TOKEN) return false;

        if (USE_MOCK_API) {
            return true; // Simulação: assume que o token é válido
        }

        try {
            // Exemplo: Fazer uma chamada para um endpoint da API que valida o token
            const response = await fetch(`${API_BASE_URL}/creditLimit/list`, {
                headers: { 'Authorization': `Bearer ${BEARER_TOKEN}`, 'Content-Type': 'application/json' }
            });
            return response.ok; // Se a resposta for OK, o token é válido
        } catch (error) {
            console.error('Erro ao verificar token:', error);
            return false;
        }
    }

    // Função de inicialização para verificar o estado de login
    async function initializeApp() {
        if (BEARER_TOKEN && LOGGED_IN_USER_EMAIL) {
            const isTokenValid = await checkTokenValidity();
            if (isTokenValid) {
                userEmailDisplay.textContent = LOGGED_IN_USER_EMAIL;
                loginScreen.classList.add('hidden');
                appScreen.classList.remove('hidden');
                loadAndRenderLimits();
            } else {
                handleLogout(); // Token inválido, força logout
            }
        }
    }

    // --- FUNÇÕES DE LOG ---
    function logChange(action, document, details = {}) {
        const timestamp = new Date().toLocaleString('pt-BR');
        const logEntry = {
            user: LOGGED_IN_USER_EMAIL,
            action,
            clientDocument: document,
            details,
            timestamp
        };
        console.log('LOG:', logEntry);
    }

    // --- FUNÇÕES DE API ---
    const mockCreditLimits = [
        { document: '11222333000144', credit_type: 'AVISTA', value: 10000.00, balance: 7500.50, active: true, without_credit_limit: false, last_updated: '2025-10-05T14:30:00Z' },
        { document: '99888777000155', credit_type: 'PRAZO_30D', value: 50000.00, balance: 12345.00, active: true, without_credit_limit: true, last_updated: '2025-10-06T10:15:00Z' },
        { document: '12345678900', credit_type: 'ESPECIAL', value: 5000.00, balance: 0, active: false, without_credit_limit: false, last_updated: '2025-09-28T09:00:00Z' }
    ];

    async function fetchCreditLimits(document = '') {
        if (USE_MOCK_API) {
            console.log(`[MOCK] Buscando limites para documento: ${document}`);
            if (!document) {
                return Promise.resolve({ success: true, data: mockCreditLimits });
            }
            const cleanDoc = document.replace(/\D/g, '');
            const data = mockCreditLimits.filter(limit => limit.document.includes(cleanDoc));
            return Promise.resolve({ success: true, data: data });
        }

        const url = new URL(`${API_BASE_URL}/creditLimit/list`);
        url.searchParams.append('limit', '25');
        if (document) url.searchParams.append('document', document.replace(/\D/g, ''));

        try {
            const response = await fetch(url, { headers: { 'Authorization': `Bearer ${BEARER_TOKEN}`, 'Content-Type': 'application/json' } });
            if (!response.ok) throw new Error(`Erro na API: ${response.statusText}`);
            const data = await response.json();
            return { success: true, data };
        } catch (error) {
            console.error('Falha ao buscar limites:', error);
            showNotification(`Erro ao buscar: ${error.message}`, 'error');
            return { success: false, data: [] };
        }
    }

    async function saveCreditLimit(limitData) {
        const isEditing = !!isEditingInput.value;
        
        if (USE_MOCK_API) {
            const dataToSave = { ...limitData, last_updated: new Date().toISOString() };
            const existingIndex = mockCreditLimits.findIndex(l => l.document === dataToSave.document && l.credit_type === dataToSave.credit_type);
            if (existingIndex > -1) {
                mockCreditLimits[existingIndex] = { ...mockCreditLimits[existingIndex], ...dataToSave };
            } else {
                mockCreditLimits.push(dataToSave);
            }
            logChange(isEditing ? 'ATUALIZOU LIMITE' : 'CRIOU LIMITE', dataToSave.document, { newValues: dataToSave });
            return Promise.resolve({ success: true, data: dataToSave });
        }
        
        try {
            const response = await fetch(`${API_BASE_URL}/creditLimit/save`, { method: 'POST', headers: { 'Authorization': `Bearer ${BEARER_TOKEN}`, 'Content-Type': 'application/json' }, body: JSON.stringify(limitData) });
            if (!response.ok) {
                 const errorBody = await response.json();
                 throw new Error(errorBody.message || `Erro na API: ${response.statusText}`);
            }
            const data = await response.json();
            logChange(isEditing ? 'ATUALIZOU LIMITE' : 'CRIOU LIMITE', data.document, { newValues: data });
            return { success: true, data };
        } catch (error) {
            console.error('Falha ao salvar limite:', error);
            showNotification(`Erro ao salvar: ${error.message}`, 'error');
            return { success: false };
        }
    }
    
    async function saveCreditLimitType(typeData) {
        if (USE_MOCK_API) {
            const newType = { ...typeData, date_created: new Date().toISOString() };
            updateCreditTypeDropdown(newType);
            logChange('CRIOU TIPO DE LIMITE', 'N/A', { newType });
            return Promise.resolve({ success: true, data: newType });
        }
        
        try {
            const response = await fetch(`${API_BASE_URL}/creditLimit/saveTypeCreditLimit`, { method: 'POST', headers: { 'Authorization': `Bearer ${BEARER_TOKEN}`, 'Content-Type': 'application/json' }, body: JSON.stringify(typeData) });
            if (!response.ok) {
                const errorBody = await response.json();
                throw new Error(errorBody.message || `Erro na API: ${response.statusText}`);
            }
            const data = await response.json();
            updateCreditTypeDropdown(data);
            logChange('CRIOU TIPO DE LIMITE', 'N/A', { newType: data });
            return { success: true, data };
        } catch (error) {
            console.error('Falha ao salvar tipo:', error);
            showNotification(`Erro ao salvar tipo: ${error.message}`, 'error');
            return { success: false };
        }
    }

    async function deleteCreditLimit(document, credit_type) {
        const limitToDelete = currentLimits.find(l => l.document === document && l.credit_type === credit_type);
        if (!limitToDelete) {
            showNotification('Limite não encontrado para desativar.', 'error');
            return;
        }
        const updatedLimit = { ...limitToDelete, active: false };
        const result = await saveCreditLimit(updatedLimit);
        if (result.success) {
            showNotification('Limite desativado com sucesso!', 'success');
            logChange('DESATIVOU LIMITE', document, { type: credit_type });
            loadAndRenderLimits(searchInput.value);
        }
    }

    // --- FUNÇÕES DE RENDERIZAÇÃO E UI ---
    function formatDocument(doc) {
        if (!doc) return '';
        const cleanDoc = doc.replace(/\D/g, '');
        if (cleanDoc.length === 11) return cleanDoc.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4');
        if (cleanDoc.length === 14) return cleanDoc.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d{2})/, '$1.$2.$3/$4-$5');
        return doc;
    }

    function formatCurrency(value) {
        return new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(value);
    }
    
    function formatBoolean(value) {
        const text = value ? 'Sim' : 'Não';
        const color = value ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
        return `<span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${color}">${text}</span>`;
    }

    function formatDateTime(isoString) {
        if (!isoString) return 'N/A';
        try {
            const date = new Date(isoString);
            if (isNaN(date.getTime())) return 'N/A';
            return date.toLocaleString('pt-BR');
        } catch (e) {
            return 'Data inválida';
        }
    }

    function renderTable(limits) {
        tableBody.innerHTML = '';
        if (!limits || limits.length === 0) {
            tableBody.innerHTML = '<tr><td colspan="8" class="text-center p-8 text-gray-500">Nenhum limite de crédito encontrado.</td></tr>';
            return;
        }
        
        const sortedLimits = limits;
        currentLimits = sortedLimits;

        sortedLimits.forEach(limit => {
            const row = document.createElement('tr');
            row.className = 'hover:bg-gray-50';
            row.innerHTML = `
                <td class="py-4 px-4 whitespace